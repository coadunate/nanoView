<!doctype html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" href="../style/pileup.css" />
<link rel="stylesheet" href="demo.css" />
<style>


  text {
      font: 10px sans-serif;
  }

  .plot {
      position: absolute;
  }

  #plot-canvas {
      z-index: 2;
  }

  #axis-svg {
      z-index: 1;
  }

  .axis path,
  .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
  }

  .tick line{
      opacity: 0.2;
  }
</style>
</head>

<body>

</div>
<script>var newDOpts = {
  pointRadius: 2,
  lineWidth: 2
}</script>
<svg id="axis-svg" class="plot" style="margin-top:40px;"></svg>
<button type="button" name="button" onclick="renderSignalPlot(newDOpts)">Sup</button>
<canvas id="plot-canvas" class="plot"></canvas>
<div id="pileup"></div>
</body>

<script src="../node_modules/stats.js/build/stats.min.js"></script>
<script src="../dist/pileup.js"></script>
<!-- or:
<script src="../dist/pileup.min.js"></script>
-->

<script src="data.js"></script>
<script src="https://canvasjs.com/assets/script/canvasjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.12/d3.min.js" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.0.0/lodash.min.js"></script>
<script src="playground.js"></script>
<script>

    var pileupRange = p.getRange() ? p.getRange() : range;
    // constants
    var subsetSize = 100;
    var drawingOptions = {
      pointRadius: 2,
      lineWidth: 2
    }

    var READ_COLORS = [
      "#F5A9A9",
      "#F3E2A9",
      "#BEF781",
      "#81F79F",
      "#81F7D8",
      "#58ACFA",
      "#8258FA",
      "#9A2EFE",
      "#FE2EF7"
    ];

    // save the index of the currently selected point
    var selectedPoint;

    // define all size variables
    var margin = {top: 60, right: 10, bottom: 30, left: 120};
    var fullWidth = window.innerWidth - margin.right;
    var fullHeight = 500;
    var width = fullWidth - margin.left - margin.right;
    var height = fullHeight - margin.top - margin.bottom;

    // generate random dataset
    var randomX = d3.random.normal(0, 30);
    var randomY = d3.random.normal(0, 30);

    // var data = d3.range(numberPoints).map(function(d, i) {
    //     return {
    //         x: randomX(),
    //         y: randomY(),
    //         i: i, // save the index of the point as a property, this is useful
    //         selected: false
    //     };
    // });

    var data = [];

    /** Returns a JSON array containing the event information of the given range. */
    var getEventData = function(range) {
      var result = [];
      var xhttp = new XMLHttpRequest();

      xhttp.open("GET", "http://127.0.0.1:5000/getrange/start=" + range.start + "&end=" + (range.stop+1) + "&name=tt", false);
      xhttp.onload = function() {
        result = JSON.parse(xhttp.responseText);

      };
      xhttp.send();

      var a = result;
      var read = [];
      for(var i = 0; i < a.length; a++){
        if(i%2!= 0){
          var x = [];
          var y = [];
          for(var j = 0; j < a[i].length; j++){
            if(i%2!=0){
              for(var k = 0; k < a[i][j]; k++){
                x.push(a[i][j][k][0]);
                y.push(a[i][j][k][1]);
                console.log(a[i][j][k][1])
              }
            }
          }
          read.push(x);
          read.push(y);
        }
      }

      // var finalReads = [];
      // for(var i = 0; i < result.length-1; i++){
      //   if(i%2!= 0){
      //     var oneRead = [];
      //     for(var j = 0; j < result[i].length; j++){
      //       if(j%2!=0){
      //
      //         var subEvents = [];
      //         var x = [];
      //         var y = [];
      //         for(var k = 0; k < result[i][j].length; k++){
      //           console.log(result[i][j][k]);
      //         }
      //         oneRead.push(x);
      //         oneRead.push(y);
      //       }
      //     }
      //     finalReads.push(oneRead);
      //
      //     var finalDataset = [];
      //     for( var i =0; i < oneRead.length; i++){
      //       var onereadData = [];
      //       for(var k = 0; k < oneRead[i].length; k++){
      //         var x = [];
      //         var y = [];
      //         for(var l = 0; l < oneRead[i][k].length; l++){
      //           x.push(oneRead[i][k][l][0]);
      //           y.push(oneRead[i][k][l][1]);
      //         }
      //         onereadData.push(x);
      //         onereadData.push(y);
      //       }
      //       finalDataset.push(onereadData);
      //     }
      //   }
      // }
      // return finalReads;
      // event.preventDefault();
    }

    getEventData(range);


    var finalData = [];


    for(var a = 0; a < all_x.length; a++){
        var datum = {
          x: all_x[a],
          y: all_y[a],
          i: a,
          selected: false
        };
        data.push(datum);
    }

    // the canvas is shifted by 1px to prevent any artefacts
    // when the svg axis and the canvas overlap
    var canvas = d3.select("#plot-canvas")
        .attr("width", width - 1)
        .attr("height", height - 1)
        .style("transform", "translate(" + (margin.left + 1 - 36) +
            "px" + "," + (margin.top + 1) + "px" + ")");

    var svg = d3.select("#axis-svg")
        .attr("width", fullWidth)
        .attr("height", fullHeight)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," +
            margin.top + ")");

    // ranges, scales, axis, objects
    var xRange = d3.extent(data, function(d) { return d.x });
    var yRange = d3.extent(data, function(d) { return d.y });

    var xScale = d3.scale.linear()
        .domain([xRange[0],xRange[1]])
        .range([0, width]);

    // var yScale = d3.scale.linear()
    //     .domain([yRange[0] - 5, yRange[1] + 5])
    //     .range([height, 0]);

    var yScale = d3.scale.linear()
        .domain([50,150])
        .range([height, 0]);

    var xAxis = d3.svg.axis()
        .scale(xScale)
        .innerTickSize(-height)
        .outerTickSize(0)
        .tickPadding(10)
        .orient('bottom');

    var yAxis = d3.svg.axis()
        .scale(yScale)
        .innerTickSize(-width)
        .outerTickSize(0)
        .orient('left');

    // create zoom behaviour
    var zoomBehaviour = d3.behavior.zoom()
        .x(xScale)
        .y(yScale)
        .scaleExtent([1, 100])
        .on("zoom", onZoomEnd)
        //.on("zoomend", onZoomEnd);

    // append x-axis, y-axis
    var xAxisSvg = svg.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0,' + height + ')')
        .call(xAxis);

    var yAxisSvg = svg.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    // on onclick handler
    //canvas.on("click", onClick);

    // add zoom behaviour
    canvas.call(zoomBehaviour);

    // get the canvas drawing context
    var context = canvas.node().getContext('2d');

    draw(null,drawingOptions);

    // function onClick() {
    //     var mouse = d3.mouse(this);
    //
    //     // map the clicked point to the data space
    //     var xClicked = xScale.invert(mouse[0]);
    //     var yClicked = yScale.invert(mouse[1]);
    //
    //     // find the closest point in the dataset to the clicked point
    //     var closest = quadTree.find([xClicked, yClicked]);
    //
    //     // map the co-ordinates of the closest point to the canvas space
    //     var dX = xScale(closest.x);
    //     var dY = yScale(closest.y);
    //
    //     // register the click if the clicked point is in the radius of the point
    //     var distance = euclideanDistance(mouse[0], mouse[1], dX, dY);
    //
    //     if(distance < pointRadius) {
    //         if(selectedPoint) {
    //             data[selectedPoint].selected = false;
    //         }
    //         closest.selected = true;
    //         selectedPoint = closest.i;
    //
    //         // redraw the points
    //         //draw(null,drawingOptions);
    //     }
    // }

    function onZoom() {
        clearTimeout(zoomEndTimeout);
        draw(randomIndex,drawingOptions);
        xAxisSvg.call(xAxis);
        yAxisSvg.call(yAxis);
    }

    function onZoomEnd(dOpts) {
        // when zooming is stopped, create a delay before
        // redrawing the full plot
        if(dOpts)
          draw(null,dOpts);
        else
          draw(null,drawingOptions);
        xAxisSvg.call(xAxis);
        yAxisSvg.call(yAxis);


        var _range = {contig: 'burn-in', start: Math.round(xScale.domain()[0]), stop: Math.round(xScale.domain()[1]) };

        p.setRange(_range);

    }

    // the draw function draws the full dataset if no index
    // parameter supplied, otherwise it draws a subset according
    // to the indices in the index parameter
    function draw(index=null,options) {
        var active;

        context.clearRect(0, 0, fullWidth, fullHeight);
        context.fillStyle = 'steelblue';
        context.strokeWidth = 1;
        context.strokeStyle = 'blue';
        // if an index parameter is supplied, we only want to draw points
        // with indices in that array
        if(index) {
            context.beginPath();
            index.forEach(function(i) {
                var point = data[i];
                var prvPoint = i < data.length-1 ? data[i+1] : 0;
                if(!point.selected) {
                    drawPoint(point, 2,prvPoint,options);
                }
                else {
                    active = point;
                }
            });
        }
        // draw the full dataset otherwise
        else {
            context.beginPath();

            for(var i = 0; i < data.length; i++){
              var point = data[i];
              var prvPoint = i < data.length-1 ? data[i+1] : 0;

              if(!point.selected){
                drawPoint(point,options.pointRadius, prvPoint, options);
              }else {
                active = point;
              }
            }

            // data.forEach(function(point) {
            //     if(!point.selected) {
            //         drawPoint(point, pointRadius);
            //     }
            //     else {
            //         active = point;
            //     }
            // });
        }

        // ensure that the actively selected point is drawn last
        // so it appears at the top of the draw order
        if(active) {
            context.stroke = 'red';
            drawPoint(active, options.pointRadius,data[1],options);
            context.strokeStyle = 'steelblue';
        }
    }

    function drawPoint(point, r, prvPoint,options) {
        var cx = xScale(point.x);
        var cy = yScale(point.y);

        var pX = xScale(prvPoint.x);
        var pY = yScale(prvPoint.y);



        // NOTE; each point needs to be drawn as its own path
        // as every point needs its own stroke. you can get an insane
        // speed up if the path is closed after all the points have been drawn
        // and don't mind points not having a stroke



        context.beginPath();
        context.arc(cx, cy, r, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        context.lineTo(cx,cy);
        context.lineTo(pX,cy);
        context.lineTo(pX,pY);


        context.lineWidth= 2;
        context.strokeStyle='steelblue';
        context.stroke();



    }

    function euclideanDistance(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
</script>
